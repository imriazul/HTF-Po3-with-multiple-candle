//@version=5
indicator("HTF PO3 by @imriazul", overlay=true)

//==================== INPUTS ====================
grp_time = "Time Settings"
tzInput  = input.string("America/New_York", "Timezone", options=["America/New_York","Europe/London","Asia/Tokyo"], group=grp_time)
htfTf    = input.timeframe("D", "HTF Timeframe (60, 180, 240, D, W)", group=grp_time)

grp_vis  = "Visuals"
showWick = input.bool(true, "Show Wick", group=grp_vis)
showBody = input.bool(true, "Show Body", group=grp_vis)

upColor   = input.color(color.rgb(11, 142, 15), "Bull Body", group=grp_vis)
dnColor   = input.color(color.new(#ff5252, 0), "Bear Body", group=grp_vis)
wickColor = input.color(color.gray, "Wick Color", group=grp_vis)

bodyWidth = input.int(2, "Body Width (bars)", minval=2, maxval=200, group=grp_vis)
wickWidth = input.int(1, "Wick Width", minval=1, maxval=4, group=grp_vis)

grp_pos     = "Position"
rightOffset = input.int(20, "Right Offset (bars)", minval=1, maxval=300, group=grp_pos)
gapBars     = input.int(1, "Gap Between Candles (bars)", minval=0, maxval=50, group=grp_pos)

grp_adv = "Advanced"
lastN   = input.int(4, "Last N Candles (includes current)", minval=2, maxval=30, group=grp_adv)

//==================== HTF CHANGE (TZ SAFE) ====================
bool isNewHTF = ta.change(time(htfTf, tzInput))

//==================== TRACK CURRENT HTF ====================
var float curO = na
var float curH = na
var float curL = na
float curC = close

//==================== COMPLETED HISTORY ARRAYS ====================
var array<float> histO = array.new_float()
var array<float> histH = array.new_float()
var array<float> histL = array.new_float()
var array<float> histC = array.new_float()

//==================== DRAW HANDLE ARRAYS ====================
var array<line> wickArr = array.new_line()
var array<box>  bodyArr = array.new_box()

//==================== HELPERS ====================
f_deleteAllHandles() =>
    int sz = array.size(wickArr)
    if sz > 0
        for i = 0 to sz - 1
            line lw = array.get(wickArr, i)
            box  bx = array.get(bodyArr, i)
            if not na(lw)
                line.delete(lw)
            if not na(bx)
                box.delete(bx)

f_resizeHandleArrays(_n) =>
    f_deleteAllHandles()
    array.clear(wickArr)
    array.clear(bodyArr)
    for i = 0 to _n - 1
        array.push(wickArr, na)
        array.push(bodyArr, na)

// resize when lastN changes
if array.size(wickArr) != lastN
    f_resizeHandleArrays(lastN)

//==================== SHIFT ON NEW HTF ====================
if isNewHTF and not na(curO) and bar_index > 0
    array.push(histO, curO)
    array.push(histH, curH)
    array.push(histL, curL)
    array.push(histC, close[1])

    // keep only last (lastN - 1) completed candles
    while array.size(histO) > (lastN - 1)
        array.shift(histO)
        array.shift(histH)
        array.shift(histL)
        array.shift(histC)

//==================== UPDATE CURRENT HTF ====================
if isNewHTF or na(curO)
    curO := open
    curH := high
    curL := low
else
    curH := math.max(curH, high)
    curL := math.min(curL, low)

//==================== DRAW FUNCTION ====================
f_drawCandle(_o, _h, _l, _c, _x) =>
    line w = na
    box  b = na
    if not na(_o) and not na(_h) and not na(_l) and not na(_c)
        float top = math.max(_o, _c)
        float bot = math.min(_o, _c)
        if top == bot
            top += syminfo.mintick
        color bodyCol = _c >= _o ? upColor : dnColor
        int leftX  = _x - int(math.floor(bodyWidth / 2))
        int rightX = _x + int(math.ceil(bodyWidth / 2))
        if showWick
            w := line.new(_x, _h, _x, _l, color=wickColor, width=wickWidth)
        if showBody
            b := box.new(leftX, top, rightX, bot, bgcolor=bodyCol, border_color=color.new(bodyCol, 0))
    [w, b]

//==================== FIXED RIGHT POS ====================
int anchorX = bar_index + rightOffset
int stepX   = bodyWidth + gapBars

// delete old drawings + clear slots
f_deleteAllHandles()
for i = 0 to lastN - 1
    array.set(wickArr, i, na)
    array.set(bodyArr, i, na)

// completed count
int completed = array.size(histO)
int showCompleted = math.min(lastN - 1, completed)

// draw completed (oldest -> newest among shown)
if showCompleted > 0
    for i = 0 to showCompleted - 1
        int idx = completed - showCompleted + i
        float o = array.get(histO, idx)
        float h = array.get(histH, idx)
        float l = array.get(histL, idx)
        float c = array.get(histC, idx)
        int x = anchorX + stepX * i
        [tw, tb] = f_drawCandle(o, h, l, c, x)
        array.set(wickArr, i, tw)
        array.set(bodyArr, i, tb)

// draw current at the end
int curPos = showCompleted
if curPos <= lastN - 1
    int xC = anchorX + stepX * curPos
    [cw, cb] = f_drawCandle(curO, curH, curL, curC, xC)
    array.set(wickArr, curPos, cw)
    array.set(bodyArr, curPos, cb)